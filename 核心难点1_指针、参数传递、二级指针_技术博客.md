# 数据结构核心难点梳理：指针、参数传递与二级指针

## 1. 关于函数参数列表

参数列表里的东西，也是一种定义，比如

```c
isEmpty(SqQueue *q)
```

就是定义了被传递的参数，应该是 “一个地址值”，什么样的地址值呢？SqQueue 类型的地址值。所以我们就先理清楚了这一点。

## 2. 关于 -> 和 .

-> 是 通过指针访问，为什么说通过指针访问呢？因为指针变量存储的值是一个 “地址” 类型的值，至于什么样的地址类型，千奇百怪 -- 可以是 int 的地址类型，char 的，也可以是结构体的。在这里，我们传进来的参数，是一个结构体类型的指针，所以我们访问结构体内部的变量，就要用`q->front`这样的方式，-- 通过 q 找到结构体，再通过 front 找到 front 下标对应的地方（当然，更准确一些，就是这个队列的队头。）

. 是通过结构体变量访问成员，假如我们的函数定义为

```c
isEmpty(SqQueue q)
```

那么这个时候这个 q 就只是一个结构体变量而已，我们可以通过它访问结构体内部的元素，但是注意 -- 它应该是只在主函数里你要用的时候好用，比如说你已经定义了结构体，想改里面东西的值，可以直接

```c
q.front=10;
```

这样赋值。而一旦你要用函数参数传递，就不行了 -- 因为普通结构体变量，在传递的时候，只会把这个结构体复制一遍，交给功能函数操作，函数操作一通返回值之后，什么都没改，因为原函数里的结构体还是那样（如果你没有写

```c
int n=功能函数（。。。）
```

这样直接赋值的语句的话）同样的，如果你只是简单的定义为`isEmpty(SqQueue q)`的话，也就不能用 -> 了，原因很简单 --q 不是指针类型的变量，它什么变量类型都不是。

## 3. 到底是 int 还是指针

需要理清楚的是，是 int 还是指针，只取决于你在结构体里是怎么定义的，比如说链表，它的数据域 data 指针域 next， 那么`->data` 的东西，就是 int 你要改或者怎么样，就要解引用之类的了，而`->next`还是指针，因为你就是这样定义的。这也解释了队列的修改方式：`q->data[q->rear]`，这里的`q->data`就是通过结构体指针 q 找到 data 数组（更确切的说，就是起始地址，数组名就代表了起始地址。）`q->rear`就是一个数据，更确切的说就是下标的数值，就像普通数组`a[10]`里的 10 那样，只是这里的 10 我们直接写，rear 我们需要通过 q 这个指针以 -> 的方式访问，找到 rear 这个地方。

## 4. 怎么赋值

很简单，什么变量类型，赋什么值，指针就是地址值，char 就是字符，int 就是数字。

## 5. 关于起始位置

那为什么`SqQueue *q`就能直接把这个结构体找到？很简单，无论是链式结构，还是顺序结构，你定义它们的时候，就已经定下了它们在内存中的状态 -- 比如说，顺序类型，我只要知道起始位置，就可以顺下去把你一整个结构都找到，而链式类型，你的每一个元素，都包含一个指向下一个元素位置的指针，那我找到第一个，就能顺着那个指针，找到下一个内存 -- 也就是下一个元素的地方。

## 6. 现在，该面对二级指针了

```c
HeadInsert(Node* (*head),int val )
```

-- 别管那么多，就这样去看！首先，什么都别想，我们就想一个问题，你要头插，是不是得先找到链表在哪，然后把要插的那个值，变成新节点？那首先，我们得找到链表，你在 main 函数里写下了

```c
Node *head=NULL;
```

就把链表存住了 -- 因为先前，你已经通过结构体定义了链表，现在，这个链表的头节点，已经为空。那么现在，你是不是要操作链表了？记住一句话：函数要改值，就要传地址！所以，我们用`&head`，作为传递参数的数据 -- 这样，我们就真的可以操作节点了。那我的函数怎么设计呢？别管那么多，函数里得有个 newNode 吧？这就是我们的新头节点，我们通过结构体的方式定义它，分配个内存先：注意了！我们已经说过，链表是离散存储的，这就意味着，我们必须要牢牢抓住它的地址！而且，它是结构体的一份子，所以，我们用

```c
Node* newNode=(Node*)malloc(sizeof(Node))
```

的方式来分配内存，这样，我们首先用`Node*`, 限制了它指向的只能是我们要的 “结构体” 类型的一块地方 -- 避免它去存 int 数据的地址或是 char 数据的地址，然后 newNode 这个指针，就指向了一块已经开发好的内存的起始地点 -- 大小是 Node, 当然，这个指针它本身，也需要内存，所以我们申请的内存类型（针对指针的）用了`Node*`.好了，内存已经划好，我们用

```c
newNode->data=val;
```

的方法先把头节点的数据存好 -- 回顾前文，data 是 int, 而且，newNode 来帮我们找到这个地方 -- 通过 newNode 找到这个结构体元素 (因为链表是离散的，所以我们用 “元素” 说节点)，再访问 data。接下来，我们要让新节点的 next 的值，变成原来 head 的地址值，我们已经传进来了`&head`, 就愉快的先用传进来的那个变量来赋值吧，那参数就先定成 `Node* head`吧。我们写下

```c
newNode->next=head;
```

然后再写下

```c
head=newNode;
```

停！对吗？“函数传递值，就要改地址！”，我们的参数定的是 head, 意味着什么？是不是意味着我们调用的时候 -- 比如说，

```c
Insert(&head,10)
```

我们把主函数的 head 的地址值给了那个`Node* head`, 其实只是把地址值拷贝了一份给他而已，我们主函数的地址值，好像没动！是不是这样，那怎样让我们主函数的地址值动呢？” 就要改地址！“还记得吗，我们拿到它地址值的原件！也就是说，我们要再用一个指针，这个指针指向的是记录主函数 head 地址值的那块内存！所以，我们函数的参数，就得是 `Node* (*head)`--`Node*` 确定类型 -- 无论怎样他都只能改” 存 Node 节点地址的变量 “，`*head` 就是我们的新指针 -- 它是一个指针，指向的内存记录的，是主函数 head 的地址值。好像有点拗口，我们走一遍：`newNode->next=*head`--`*head`是一个指针，它指向的内存上的值是主函数 head 的地址值，我们通过这样的方式，把主函数 head 的地址值，赋值给了`newNode->next`.`*head=newNode;`--newNode 就是我们的新头节点的地址值，前面说过了，它是个指针，`*head`也是一个指针，这样的赋值达成了什么效果呢？我们把新头节点的地址值，赋值给了”`*head`这个指针指向的内存上的值 “，也就是” 主函数里 head 的地址值 “，这样，就成功了。